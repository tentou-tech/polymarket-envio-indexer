#######################################################
# Entity Related to Wallet Indexer
#######################################################

type Wallet {
  "wallet address"
  id: ID!
  "signer address"
  signer: String!
  "'proxy' or 'safe'"
  walletType: WalletType!
  "USDC.e balance"
  balance: BigInt!
  "Last transfer timestamp"
  lastTransfer: Int!
  "Creation timestamp"
  createdAt: Int!
}

enum WalletType {
  Proxy
  Safe
}

type GlobalUSDCBalance {
  "Empty string"
  id: ID!
  "Global USDC.e balance"
  balance: BigInt!
}

#######################################################
# Entity Related to UMA Sports Oracle
#######################################################

enum Ordering {
  Home
  Away
}

enum GameState {
  Created
  Settled
  Canceled
  Paused
  EmergencySettled
}

type Game {
  "The Game ID"
  id: ID!
  "Ancillary Data"
  ancillaryData: String!
  "The ordering of the game"
  ordering: Ordering!
  "The state of the game"
  state: GameState!
  "The score of the home team"
  homeScore: BigInt!
  "The score of the away team"
  awayScore: BigInt!
}

enum MarketState {
  Created
  Resolved
  Paused
  EmergencyResolved
}

enum MarketType {
  moneyline
  spreads
  totals
}

type Market {
  "The Market Id"
  id: ID!
  "The Game Id the Market is linked to"
  gameId: String!
  "The state of the Market"
  state: MarketState!
  "The Market type"
  marketType: MarketType!
  "The underdog of the Market, must be home or away, used for Spreads"
  underdog: String!
  "The line of Market, used for Spreads and Totals"
  line: BigInt!
  "The payouts set when the Market is resolved"
  payouts: [BigInt!]!
}

#######################################################
# Orderbook Related Entities
#######################################################

type MarketData {
  "ERC1155 TokenID of the CTF Asset"
  id: ID!
  "Condition that the token is linked to"
  condition: String!
  "Outcome Index, may not be present if an FPMM is not created"
  outcomeIndex: BigInt
}

type OrderFilledEvent {
  "Transaction hash + Order hash"
  id: ID!
  "Transaction hash"
  hash: String!
  "Timestamp at which filled occurred"
  timestamp: Int!
  orderHash: String!
  "Addresses of the maker and the taker"
  maker: String!
  taker: String!
  "Maker assetId"
  makerAssetId: String!
  "Taker assetId"
  takerAssetId: String!
  "Maker amount filled"
  makerAmountFilled: BigInt!
  "Taker amount filled"
  takerAmountFilled: BigInt!
  "Fee paid by the order maker"
  fee: BigInt!
}

# Exchange OrdersMatched event stored directly
type OrdersMatchedEvent {
  "TransactionHash_LogIndex"
  id: ID!
  "Transaction hash"
  hash: String!
  "Timestamp at which filled occurred"
  timestamp: Int!
  "Maker asset Id"
  makerAssetID: BigInt!
  "Taker asset Id"
  takerAssetID: BigInt!
  "Maker amount filled"
  makerAmountFilled: BigInt!
  "Taker amount filled"
  takerAmountFilled: BigInt!
}

type Orderbook {
  "Token Id"
  id: ID!
  "Number of trades of any kind against this order book"
  tradesQuantity: BigInt!
  "Number of purchases of shares from this order book"
  buysQuantity: BigInt!
  "Number of sales of shares to this order book"
  sellsQuantity: BigInt!
  "Market volume in terms of the underlying collateral value"
  collateralVolume: BigInt!
  "Volume scaled by the number of decimals of collateralToken"
  scaledCollateralVolume: BigDecimal!
  "Global volume of share purchases in USDC base units"
  collateralBuyVolume: BigInt!
  "Global volume of share purchases in USDC scaled by 10^6"
  scaledCollateralBuyVolume: BigDecimal!
  "Global volume of share sales in USDC base units"
  collateralSellVolume: BigInt!
  "Global volume of share sales in USDC scaled by 10^6"
  scaledCollateralSellVolume: BigDecimal!
}

# Exchange: all trades aggregated
type OrdersMatchedGlobal {
  "ID is empty string, this is a singleton"
  id: ID!

  "Number of trades of any kind for all order books"
  tradesQuantity: BigInt!
  "Number of purchases of shares from any order book"
  buysQuantity: BigInt!
  "Number of sales of shares to any order book"
  sellsQuantity: BigInt!

  "Global volume in USDC base units"
  collateralVolume: BigDecimal!
  "Global volume in USDC scaled by 10^6"
  scaledCollateralVolume: BigDecimal!

  "Global volume of share purchases in USDC base units"
  collateralBuyVolume: BigDecimal!
  "Global volume of share purchases in USDC scaled by 10^6"
  scaledCollateralBuyVolume: BigDecimal!
  "Global volume of share sales in USDC base units"
  collateralSellVolume: BigDecimal!
  "Global volume of share sales in USDC scaled by 10^6"
  scaledCollateralSellVolume: BigDecimal!
}

#######################################################
# Open Interest Related Entities
#######################################################

type Condition {
  "conditionId"
  id: ID!
}

# Neg Risk Events/Markets
type NegRiskEvent {
  "negRiskMarketId"
  id: ID!
  "Fee Bps"
  feeBps: BigInt!
  "Question Count"
  questionCount: Int!
}

# Market Open Interest
type MarketOpenInterest {
  "Condition ID"
  id: ID!
  "Open interest for the market"
  amount: BigInt!
}

# Global Open Interest
type GlobalOpenInterest {
  "GlobalOpenInterest"
  id: ID!
  "Global Open Interest"
  amount: BigInt!
}

#######################################################
# FPMM Entities
#######################################################

type Collateral {
  "Token address"
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
}

type FixedProductMarketMaker {
  "Market maker address"
  id: ID!

  "Address which deployed this market"
  creator: String!
  "Time at which this market was deployed"
  creationTimestamp: Int!
  "Hash of deployment transactions"
  creationTransactionHash: String!

  "Token which is colleralising this market"
  collateralToken: Collateral!
  "Conditional Token Address"
  conditionalTokenAddress: String!
  "Conditions which this market is trading against"
  conditions: [String!]!
  "Percentage fee of trades taken by market maker. A 2% fee is represented as 2*10^16"
  fee: BigInt!

  "Number of trades of any kind against this market maker"
  tradesQuantity: BigInt!
  "Number of purchases of shares from this market maker"
  buysQuantity: BigInt!
  "Number of sales of shares to this market maker"
  sellsQuantity: BigInt!
  "Number of times liquidity has been added to this market maker"
  liquidityAddQuantity: BigInt!
  "Number of times liquidity has been removed from this market maker"
  liquidityRemoveQuantity: BigInt!

  "Market volume in terms of the underlying collateral value"
  collateralVolume: BigInt!
  "Volume scaled by the number of decimals of collateralToken"
  scaledCollateralVolume: BigDecimal!
  "Global volume of share purchases in USDC base units"
  collateralBuyVolume: BigInt!
  "Global volume of share purchases in USDC scaled by 10^6"
  scaledCollateralBuyVolume: BigDecimal!
  "Global volume of share sales in USDC base units"
  collateralSellVolume: BigInt!
  "Global volume of share sales in USDC scaled by 10^6"
  scaledCollateralSellVolume: BigDecimal!
  "Fees collected in terms of the underlying collateral value"
  feeVolume: BigInt!
  "Fees scaled by the number of decimals of collateralToken"
  scaledFeeVolume: BigDecimal!

  "Constant product parameter k"
  liquidityParameter: BigInt!
  scaledLiquidityParameter: BigDecimal!

  "Balances of each outcome token held by the market maker"
  outcomeTokenAmounts: [BigInt!]!
  "Prices at which market maker values each outcome token"
  outcomeTokenPrices: [BigDecimal!]!
  "Number of outcomes which this market maker is trading"
  outcomeSlotCount: Int

  "Timestamp of last day during which someone made a trade"
  lastActiveDay: Int!

  "Number of shares for tokens in the market maker's reserves"
  totalSupply: BigInt!

  "Addresses which are supplying liquidity to the market maker"
  poolMembers: [FpmmPoolMembership!]! @derivedFrom(field: "pool")
}

type FpmmPoolMembership {
  "funder address _ pool address"
  id: ID!
  "Market to which funder is providing funding"
  pool: FixedProductMarketMaker!
  "Account which is providing funding"
  funder: String!
  "Amount of liquidity tokens owned by funder"
  amount: BigInt!
}

enum TradeType {
  Buy
  Sell
}

type FpmmTransaction {
  "Transaction Hash _ Log Index"
  id: ID!
  "Buy or Sell transaction"
  type: TradeType!
  "Timestamp at which transaction occurred"
  timestamp: Int!
  "Market which transaction is interacting with"
  market: FixedProductMarketMaker!
  "Account performing transaction"
  user: String!
  "Amount of collateral in trade"
  tradeAmount: BigInt!
  "Amount of collateral paid in fees"
  feeAmount: BigInt!
  "Index of outcome token being bought or sold"
  outcomeIndex: BigInt!
  "Amount of outcome tokens being bought or sold"
  outcomeTokensAmount: BigInt!
}

type FpmmFundingRemoval {
  "Transaction Hash"
  id: ID!
  "Timestamp at which funding removal occurred"
  timestamp: Int!
  "FPMM to which funding is being removed"
  fpmm: FixedProductMarketMaker!
  "Account removing funding"
  funder: String!
  "Outcome tokens amounts removed from FPMM"
  amountsRemoved: [BigInt!]!
  collateralRemoved: BigInt!
  "Liquidity shares burned by funder"
  sharesBurnt: BigInt!
}

type FpmmFundingAddition {
  "Transaction Hash"
  id: ID!
  "Timestamp at which funding addition occurred"
  timestamp: Int!
  "FPMM to which funding is being added"
  fpmm: FixedProductMarketMaker!
  "Address adding funding"
  funder: String!
  "Outcome tokens amounts added to FPMM"
  amountsAdded: [BigInt!]!
  "Outcome tokens amounts refunded to funder"
  amountsRefunded: [BigInt!]!
  "Liquidity shares minted to funder"
  sharesMinted: BigInt!
}

#######################################################
# Activity Related Entities
#######################################################

type Split {
  "Transaction Hash"
  id: ID!
  "Timestamp at which split occurred"
  timestamp: Int!
  "Address which is performing this split"
  stakeholder: String!
  "Condition on which split is occuring"
  condition: String!
  "The amount of collateral/outcome tokens being split"
  amount: BigInt!
}

type Merge {
  "Transaction Hash"
  id: ID!
  "Timestamp at which merge occurred"
  timestamp: Int!
  "Address which is performing this merge"
  stakeholder: String!
  "Token which is collateralising positions being merged"
  condition: String!
  "The amount of collateral/outcome tokens being merged"
  amount: BigInt!
}

type Redemption {
  "Transaction Hash"
  id: ID!
  "Timestamp at which redemption occurred"
  timestamp: Int!
  "Address which is redeeming these outcomes"
  redeemer: String!
  "Condition on which redemption is occuring"
  condition: String!
  "Outcomes which are being redeemed"
  indexSets: [BigInt!]!
  "The amount of collateral being claimed"
  payout: BigInt!
}
